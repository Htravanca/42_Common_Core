ok valgrind --leak-check=full --show-leak-kinds=all ./a.out file1.txt \"cat\" \"grep foo\" \"wc -l\" file2.txt
ok mudar o return values do Exit para os codes corretos

ok ./pipex_bonus file1 "head -n 5" "grep test" "cut -d ' ' -f 1" file2
ok o split ja conta bem as palavras agora falta por o escrever bem

No pipex por a protecao caso o waitpid nao resulte

ok 
valgrind --trace-children=yes --leak-check=full --show-leak-kinds=all --track-fds=yes ./pipex file1.txt "pwd" "wc -l" "    " file2.txt
valgrind --trace-children=yes --leak-check=full --show-leak-kinds=all --track-fds=yes ./pipex infile "pwd" "wc -l" file2.txt

ok
echo $? - check the exit codes.

OK PATH=' ' ./pipex infile "ls" "wc -l" outfile

OK unset PATH
/bin/valgrind



-------------Parte mandatoria-----------------------------------
TESTE 1
./pipex /dev/stdin cat ls /dev/stdout
ls

valgrind --track-fds=all --trace-children=yes

"grep foo"
wc -l
-------------Parte bonus-----------------------------------
TESTE 1
./pipex file1.txt "cat" "grep foo" "wc -l" file2.txt
< file1.txt cat | grep foo | wc -l > file2.txt

TESTE 2
./pipex file1.txt "cat" "invalid_command" "wc -l" file2.txt

TESTE 3
./pipex file1.txt "cat" "grep something" "exit 1" file2.txt

TESTE 4
./pipex file1.txt "head -n 5" "grep test" "cut -d ' ' -f 1" file2.txt

TESTE 5
./pipex emptyfile "cat" "wc -l" "echo Done" file2.txt

TESTE 6 
./pipex file1.txt "tr a-z A-Z" "sort" "uniq" file2.txt

TESTE 7
./pipex file1.txt "cat" "grep hello" "sed 's/hello/world/'" "sort" "wc -l" file2.txt

TESTE 8
./pipex file1.txt "echo 'This is a test'" "tr -d 'aeiou'" "rev" file2.txt


  Test 4. Du, Sort, Head, and WC
        ORIGINAL - < infile du -sh * | sort -hr | head -5 | wc -l > outfile
        PIPEX - ./pipex infile "du -sh *" "sort -hr" "head -5" "wc -l" outfile


Test 6. Out of scope arguments
        ORIGINAL - < Makefile grep $ | 'awk '{ if (length($0) > max) max = length($0) } END { print max }'
        PIPEX - ./pipex Makefile "grep $" "'awk '{ if (length($0) > max) max = length($0) } END { print max }'" outfile.txt

        Explanation: This test provides complex and nested commands to ensure the program can handle more advanced and potentially out-of-scope commands.





        The issue you're encountering stems from how the exit status of child processes is being propagated to the parent process. In your main function, you're using waitpid(pid1, NULL, 0) and waitpid(pid2, NULL, 0). However, passing NULL as the second argument means that you are not capturing the exit status of the child processes, which is why the return code you get with echo $? is always 0.

To fix this, you need to capture the exit status of the child processes and handle it properly. Here's how you can modify your code:

    Create a variable to store the exit status of each child.
    Pass this variable to waitpid to capture the exit status.
    Use WEXITSTATUS(status) to retrieve the actual exit code from the status variable.

Here is an updated version of your main function:

c

int	main(int argc, char **argv, char **envp)
{
	int	fd[2];
	int	pid1, pid2;
	int	status1, status2;

	if (argc == 5)
	{
		ft_handle_error(pipe(fd), "Pipe error");
		pid1 = ft_handle_error(fork(), "Fork error");
		if (pid1 == 0)
			ft_execute_child1(fd, argv, envp);
		pid2 = ft_handle_error(fork(), "Fork error");
		if (pid2 == 0)
			ft_execute_child2(fd, argv, envp);
		close(fd[0]);
		close(fd[1]);
		waitpid(pid1, &status1, 0);  // Capture exit status of first child
		waitpid(pid2, &status2, 0);  // Capture exit status of second child

		// Check and print the exit status of child processes
		if (WIFEXITED(status1))
			printf("Child 1 exited with status: %d\n", WEXITSTATUS(status1));
		if (WIFEXITED(status2))
			printf("Child 2 exited with status: %d\n", WEXITSTATUS(status2));
	}
	else
		perror("Error in ARGS, correct usage: ./pipex file1 cmd1 cmd2 file2");
	return (0);
}

Explanation:

    waitpid(pid1, &status1, 0) captures the exit status of pid1 into status1.
    waitpid(pid2, &status2, 0) captures the exit status of pid2 into status2.
    WIFEXITED(status) checks if the child process exited normally.
    WEXITSTATUS(status) extracts the exit code from the status variable.

With this modification, you should see the correct exit status when running your program.

Let me know if this works or if you need further assistance!